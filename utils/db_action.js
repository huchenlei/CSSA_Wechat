/**
 * This module defines all database actions
 * Executing this file directly will initialize database data from card-number-pool json file
 */
const crypto = require('crypto');
const mongoose = require('mongoose');
const fs = require('fs');
const encryptCardId = require('./encrypter').encrypt;
const Promise = require('q').Promise;
mongoose.Promise = Promise; // Use q for mongoose promises

const userSchema = mongoose.Schema({
    openId: String,
    detailedInfo: {
        name: String,
        graduation: Number,
        discipline: String,
    },
    cssaCardNumber: String,
    cardAvailable: Boolean
});

const collectionName = 'users';
const conn = mongoose.createConnection('mongodb://localhost:27017/CssaWechat', {useMongoClient: true});
const User = conn.model(collectionName, userSchema); // The user model(use users collection in database)
conn.on('error', console.error.bind(console, 'connection error:'));


/**
 * Handle exceptions generated by db operations
 * @param e exception
 * @return {string}
 */
function handleException(e) {
    return typeof e === "string" ? e : "Sorry, we meet some problems with database";
}

/**
 * add empty card info to database
 * @param jsonPath the path to json public file
 * @return Promise
 */
function addAvailableCards(jsonPath) {
    const cardIds = JSON.parse(fs.readFileSync(jsonPath)); // array containing all card ids
    const users = [];
    cardIds.forEach((cardId) => {
        users.push({cardAvailable: true, cssaCardNumber: cardId});
    });
    return User.insertMany(users); // return a promise obj
}

/**
 * Drop the users collection and initialize with test data
 * [WARNING] Do NOT use this function in production env
 * @return Promise
 */
function initializeDB() {
    return User.remove().exec() // clean users collection
        .then(addAvailableCards('../data/card-pool-public.json'));
}

/**
 * Bind the wechat user to specific card in database
 * @param openId unique wechat id for each wechat user
 * @param cardNumber private card number (unencrypted)
 * @return Promise
 */
function bindUser(openId, cardNumber) {
    const encryptedCardId = encryptCardId(cardNumber);
    return User.findOne({cssaCardNumber: encryptedCardId}).then((user) => {
        if (!user) throw "Sorry, the card number seems to be invalid";
        if (!user.cardAvailable) throw "Sorry, the card is already bind to a wechat account";
    }).then(() => {
            return User.updateOne(
                {cssaCardNumber: encryptedCardId, cardAvailable: true},
                {openId: openId, cardAvailable: false});
        }
    ).then(() => {
        return "Bind card successful!";
    }).catch(handleException);
}

/**
 * Query the member information they previously filled
 * @param openId unique wechat id for each wechat user
 * @param field information field
 * @return {Promise.<T>|Promise}
 */
function queryMemberInfo(openId, field) {
    return User.findOne({openId: openId}).then((user) => {
        if (!user) throw "Sorry, you are not yet a member of CSSA, please bind a card first";
        if (!(user.detailedInfo && user.detailedInfo[field]))
            throw `The information field ${field} not yet filled, please fill the information first`;
        return `${field}: ${user[field]}`;
    }).catch(handleException);
}

/**
 * Update the member information based on valu passed in
 * @param openId
 * @param field
 * @param value
 * @return Promise
 */
function updateMemberInfo(openId, field, value) {
    return User.findOne({openId: openId}).then((user) => {
        if (!user) throw "Sorry, you are not yet a member of CSSA, please bind a card first";
        if (!(user.detailedInfo && user.detailedInfo[field])) return `Previously ${field} not set.`;
        return `Previously ${field} is ${user.detailedInfo[field]}.`
    }).then((message) => {
        let update = {};
        update[`detailedInfo.${field}`] = value;
        return User.updateOne({openId: openId}, {$set: update}).then(() => {
            return `${message} Updating to ${value}.`;
        });
    }).catch(handleException);
}

/**
 * Validate the membership of given user
 * @param openId
 * @return {Promise.<T>|Promise}
 */
function validateMember(openId) {
    return User.findOne({openId: openId}).then((user) => {
        if (!user) throw "Sorry, you are not a member of CSSA.";
        return `Yes, you are currently a member of CSSA! Your public key is ${user.cssaCardNumber}`;
    }).catch(handleException);
}

module.exports = {
    addAvailableCards,
    initializeDB,
    bindUser,
    queryMemberInfo,
    updateMemberInfo,
    validateMember
};